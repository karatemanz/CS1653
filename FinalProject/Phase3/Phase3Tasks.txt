T1: Unauthorized Token Issuance
- require password creation/confirmation
-- Group Server, when first launched without a UserList.bin file, needs to
   prompt for password when creating first user/admin
-- prompt for password when logging in
-- will need to change User/UserList class to store hashed password
-- will need to store hashed password, part of User class?
-- set up secure exchange between client and Group Server, save Group Server's
   public key for client (local to them), store also for Group Server (local to
   it? how will Group Server know its key pair?)
-- should we limit the number of characters possible for a password, or
   restrict which characters?

T2: Token Modification/Forgery
- change Token class to store signature, provide tokenized string
- set up secure exchange between client and File Server to pass information
- set up File Server to decrypt signature (how will it get Group Server public
  key?)
- set up client to accept ACK, continue on with transaction
- authorize token at every transaction

T3: Unauthorized File Servers
- have client get and store public key from File Server when first contacting
- set up secure exchange between client and File Server to pass information
- if File Server can decrypt message encrypted with the public key, then use
  the shared secret key to access File Server operations
- will need to encrypt the file transfer process - CHUNK appears to be defined
  in FileThread (download) / FileClient (upload) - 4096 bytes?

T4: Information Leakage via Passive Monitoring
- use the same methods as we used in T1 - T3 to encrypt communication, ya dummy

Notes:

